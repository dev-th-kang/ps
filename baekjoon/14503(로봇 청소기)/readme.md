# [14503(로봇 청소기)](14503.cpp)

```이 문제는 DFS와 구현을 활용하여 푸는 문제고 이해를 하지못하면 어려운 문제이다.```

<hr>

# 먼저 조건을 확인하자

1. 현재 위치를 청소한다.
2. 현재 위치에서 현재 방향을 기준으로 왼쪽방향부터 차례대로 탐색을 진행한다.
   1. 왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행한다.
   2. 왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아간다.
   3. 네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다.
   4. 네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다.

<hr>

# 이렇게 해결하자!

* 일단 조건과 마찬가지로, 현재위치를 청소한다.
    ```C++ 
    if(visitPoint[x][y] == 0 && mat[x][y] == 0){
        visitPoint[x][y] = 1;
        ans ++;
    } 
    ```

* 그리고 다음 조건으로 왼쪽방향부터 탐색을 진행한다.
    ```C++
    for(int i=robotFunc1(d);  robotFunc1(d)-3<= i ; i--){
        int nd = i;
        if(nd < 0) nd += 4;

        int nx = x + dir[nd].x;
        int ny = y + dir[nd].y;
        if(!isMapLimited(nx,ny)) continue;
        if(mat[nx][ny] == 0 && visitPoint[nx][ny] == 0) dfs(nx,ny,nd);
    }
    ```
    * 북 > 서 > 남 > 동 순서로 들어간다. 왼쪽에 정리하지않은 곳이 있다면, 2-1번 조건대로 그 방향으로 전진하고, **1번 작업을 다시 진행한다.**(재귀 함수)
      * 이렇게 원래 방향으로 4방향체크

    ```C++
    int nd = robotFunc2(d);
    int nx = x + dir[nd].x;
    int ny = y + dir[nd].y;

    if(mat[nx][ny] == 0) dfs(nx,ny,d);
    ```
    >robotFunc2는 북>남, 서>도, 남>북, 동>서로 반대 방향을 체크하기 위해서 방향을 반대로 틀어주는 것이다.
    * 4뱡향이 모두 청소가 되거나, 벽인 경우에 **방향을 유지** 한 상태로, 후진을 하고 다시 2번 작업을 진행한다.
    * 
    ```C++ 
    if(mat[nx][ny] == 0) dfs(nx,ny,d); 가 제일 중요한다.
    " dfs(nx,ny,d) "에서 nd가 아니라 d가 들어간다. 뒤쪽방향을 구한것은, 후진된 좌표를 구하기 위함이고, 방향을 유지하기 위해, 후진된 nx, ny와 원래의 방향 d를 인자값으로 넘겨준다.
    ```

<hr>

## 소감
``` 말 뜻을 이해하기가 조금 어려웠을 뿐, 내용을 제대로 이해하고, 문제를 푼다면, 어렵지않다. 골드5 난이도지만, 문제의 이해여부에 따라서 골드3정도의 난이도가 맞는거 같다. 이 문제는 삼성 코테에서도 출현한 문제이며, 가장 대표적인 구현문제니, 잘 알아두길 바란다.```
