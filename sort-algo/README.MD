# SORT

## QuickSort

> 퀵소트는 시간 복잡도가 O(n log n)에서 최악의 경우에는 O(n²)까지 걸릴 수 있다.
> 거의 정렬 되어있을 때 n²이 걸린다는 특징이 있습니다. 이 형태를 막기 위해서는 배열을 섞어주게되면
> 최악의 경우를 피할 수 있습니다.


* pivot을 제일 왼쪽으로 선정
* pivot을 제외한 배열에서 제일 왼쪽을 i, 제일 오른쪽으로 j로 둔다.
    1. arr[i]의 값이 arr[pivot]의 값보다 작거나 같을 때마다 i++ 을 진행한다.
    2. arr[j]의 값이 arr[pivot]의 값보다 크거나 같을 때마다 j-- 을 진행한다.

* i와 j 가 엇갈렸는지 확인 후, 엇갈리지 않았으면 arr[i]와 arr[j]를 스왑하고 이전의 단계를 다시 진행한다.
* i와 j 가 엇갈렸을 경우에는 arr[j]와 arr[pivot]의 값을 swap한다. 그리고 j번째의 값이 정리 되었으므로, 
  j를 기준으로 왼쪽 오른쪽을 나눠서 분할 정복을 진행한다.

<BR>

* 왼쪽
```c++ 
    quickSort(l,j-1); 
```
* 오른쪽
```c++ 
     quickSort(j+1,r);
```