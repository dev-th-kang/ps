# [9205(맥주 마시면서 걸어가기)](9205.cpp)

```이 문제는 bfs를 쓰면 쉽게 풀 수 있는 문제이다. 무조건적으로 편의점을 중점적으로 문제를 봐야한다.```

## 문제의 조건
* 50m 당 맥주 1명
* 총 맥주 20개 / 맥주를 최대 소지할 수 있는 것도 20개
  * 편의점에 도착하면 가득채울 수 있고, 나선 직후에 맥주 한병을 먹어야한다.
* x,y 의 범위가 -범위까지 포함된다. 절대값 연산이 필요하다.
#

## 문제 풀이 
편의점 의 x,y 좌표 각각 입력받는 것과 goal(페스티벌) x,y 좌표를 받는 것이 매우 중요하다.

```C++
		for (int i = 0; i < N; i++) 
			cin >> store[i].x >> store[i].y;
		cin >> goal.x >> goal.y;
```
* 1 => (x1 - x2) / 2 => (y1 - y2)
* abs(x1 - x2) - abs(y1 - y2) 는 대각선이 아니고, 직선으로 갔을때 1에서부터 2까지의 가야되는 거리를 산출해준다.
    ```C++
    if (absV(x - goal.x) + absV(y - goal.y) <= 1000) {
        printf("happy\n");
        return;
	}
    ```
  * 이 때, 거리가 1000m(맥주20캔 * 한캔당 50m) 이내 일때, 갈 수 있으니깐, happy를 return 한다.
* 다음 목적지를 festival로 잡지않는다. 페스티벌은 위에서 계속 연산해서 잡아주기 때문이다. 연산을 지속되게하기위해서 다음 x,y를 잡아줘야하는데 1000m 조건이기에, x,y 축을 다음으로 갈 수 있는 편의점을 기준으로 해야한다. 그리고 편의점 거리가 1000m 안으로 갈 수 있다면, 편의점으로 가서 20캔을 완충한뒤 목적지를 찾는 작업을 반복한다.
#

# 쉬운 도식화

1. 1000m 반경에 목적지가 있냐?
   * 있으면, happy출력 후 return
   * 없으면 2번조건 진행

2. 1000m 반경에 편의점은 있냐?
   * 있으면 편의점을 중심으로 1번조건을 다시간다.
   * 
3. 1000m 반경에 편의점도 없고, 1000m 반경에 목적지도 없으면, sad를 출력

#
## 소감

> 난이도 자체는 쉽지만, 헷갈릴 수 있었던 형태인거 같다. 일반적으로 좌표 이동 보다는 반경을 기준으로 그 좌표가 존재하면, posit point를 계속 변경해가면서 가는 형태이다. 