# [1194(달이 차오른다, 가자.)](./1194.cpp)

```이 문제는 BFS와 비트마스킹을 활용하여 푸는 문제이다.```

먼저 이 문제는 '0'을 시작점으로 잡고, BFS를 진행한다.

```C++
if(!isMapLimited(nx,ny)) continue;
if(mat[nx][ny] == '#' ) continue;
```
위의 코드로, 불필요한 길이거나, map의 한도를 초과했을 때 조건문을 건너뛴다.
<hr>

## KEY를 발견했을 때
> 'a'~'f'의 key 를 발견했을 때의 연산처리
```c++
int nkey = key|(1<< (mat[nx][ny]-'a'));
```
* 2진수로 했을때
  * 없을때 = 0
  * a = 1 (1)
  * b = 10 (2)
  * c = 1000 (4)
  * d = 10000 (8)
  * e = 100000 (16)
  * f = 1000000 (32)
  * 총 64가지의 경우
> 원래 있던거에서 or 연산을 진행해서 열쇠값 저장

<hr>

## 문을 만났을 때
> 'A'~'F'의 문을 만났을때 연산처리

```c++
int cKey = key &(1<< (mat[nx][ny]-'A'));
if(cKey ==0|| visitPoint[key][nx][ny] !=0) continue;;
```
> mat[nx][ny] -'A'를 하게되면, 
> 'a' - 'A', 'b' - 'B' 처럼 알파벳 매핑이 가능해진다.

* 이를 토대로 and연산을 진행해서 0이 나오면, 포함된 키가 없는 것이므로, 가려고 했던곳이 이미 갔던 곳이거나, 키가 없으면, 건너뛰는 작업을 한다.

<hr>

## 일반 길에 대한 처리

```C++
if(visitPoint[key][nx][ny] !=0) continue;
q.push({{nx,ny},key});
visitPoint[key][nx][ny]  =visitPoint[key][x][y] +1;
```
* 일반 BFS와 마찬가지로 처리하면된다.


## 소감
```일반적인 BFS와 같지만, 비트마스킹을 이용해서 좀 더 응용된 처리를 하면서 BFS작업을 하면된다. 난이도는 골1로 되어있지만, 이해만 한다면 골드5정도의 난이도로 체감된다.```
