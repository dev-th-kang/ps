# [2240( 자두나무 )](./2240.cpp)

```이 문제는 DP를 활용하여 푸는 문제이다.```

먼저 이 문제는 **1번나무**를 기점으로 시작한다.

* 0 ~ W 만큼 걷는걸 bottom-up 형태를 이용해서 풀면 된다.
*  아래의 코드가 제일 중요한 점화식 코드이다.
    ```C++
    dp[i][j][1] = max(dp[i-1][j-1][2] + (tree[i] ==1), dp[i-1][j][1] + (tree[i] ==1));
    
    dp[i][j][2] = max(dp[i-1][j-1][1] + (tree[i] ==2), dp[i-1][j][2] + (tree[i] ==2));
    ```
> 위의 코드에서 첫번째는 1번나무 = 이전나무가 2일때의 값과 이전나무가 그대로 1일 때의 값중에 큰 값을 넣는다.

> 위의 코드에서 두번째는 2번나무 = 이전나무가 1일때의 값과 이전나무가 그대로 2일 때의 값중에 큰 값을 넣는다.

* 예외 코드
    ```C++
    if(j==0) dp[i][j][1] = dp[i-1][j][1] + (tree[i] == 1);
    ```
    * 위의 코드는 한번도 이동하지않았을 때의 값은 무조건적으로 1번 나무 이므로, 이전의 1번나무 + 1을 한다.


* 비트마스킹 사용
  * 코드에서는 비트마스킹을 사용해서 코드의 길이를 드라마틱하게 줄였다. (tree[i] == 1) 을 더하게되면 tree[i] == 1 일 경우 1이 더해지고, tree[i] == 0 일 경우 0이 더해진다. boolean 형태의 값이 int 로 변환대서 조건에 일치하면 1이 더해지게된다.
  