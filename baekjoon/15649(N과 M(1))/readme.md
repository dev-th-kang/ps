# [15649( N과 M(1) )](./15649.cpp) 😁 시리즈

``` 이 문제는 DFS의 기초형태와, 백트래킹을 사용하면 풀 수 있다. ```

## DFS에 백트래킹이 포함된거 아닌가요?

* 백트래킹에 DFS안에 내포되어있긴한다.
* 하지만, 여기서 설명하는 백트래킹은 visitPoint[i]로 방문을 확인하고 dfs를 완료하면 visitPoint[i]를 방문하지않은 상태로 변경하게 된다.

* 쉽게 비유하자면, 닫혀있는 방의 문을 열고 들어갔는데, 나올때 닫은채로(들어간 흔적x) 다시 나오는 그런 형태이다.


<hr>

## 소스 설명
```c++
for (int i = 1; i <= n; i++)
{
    if (!visitPoint[i])
    {
        arr[k] = i;
        visitPoint[i] = true;
        dfs(k + 1);
        visitPoint[i] = false;
    }
}
```

> 이 부분은 기존의 DFS와 거의 똑같다. arr[]에 수열의 값을 넣어주는 부분과 dfs진행하고, visitPoint[i]를 다시 false로 초기화 해주는 부분을 제외하면 DFS와 동일한 부분이다.

* visitPoint[i]가 항상 마지막에 false가 되기때문에 DFS처럼 중간에 끝나는 포인트가 없다. 그러므로 k가 m이 되었을 때, 출력 후 함수를 종료하는 것으로 한다. 

<hr>

## 쉬운 설명
좀 더 쉬운 설명을 하자면, n과 m이 있다.

✔ n은 노드의 수  ✔ m은 한줄에 출력할 수열의 수

* DFS의 형태이긴 하지만, 백트래킹 특성상, 왔던 길(visitPoint[i])을 다시 false로 해야되기 때문에 함수를 빠져나가는 코드가 없으면, 재귀지옥에 빠진다.

* 그렇기 때문에, k==m의 조건식을 세워서 수열의 한줄이 완성되면 한 줄만큼 출력을한다.

<hr>

## 소감

조금 어려운 개념이다. 하지만, 왔던길을 다시 덮고, k == m조건문이 한줄의 수열을 빼내기위함인걸 인지하면, 그렇게 난이도가 높다고 생각되지않을것이다. 하지만 처음 접하면, 풀기 힘든 문제인걸 감안하면, 실버1정도의 수준의 난이도라고 생각한다.