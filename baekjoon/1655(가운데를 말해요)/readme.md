# [1655(가운데를 말해요)](1655.cpp)

```이 문제는 자료구조를 이용해서 푸는 문제이다. 중간값을 계속해서 도출해야하기 때문에, 정렬된 상태가 되야한다. 들어가자마자 자동으로 정렬이 되는 자료구조는 대표적으로 우선순위 큐가 있다. 우선순위 큐를 써서 해결하면 되는 대표적인 자료구조 유형이다. 😁😁```

## 문제의 접근 방식

* 무턱대고, vector나 deque를 넣었다가 시간초과가 나는 경우가 있었을꺼다. 이 문제가 시간제한이 0.1초로 극악이다. 기본적으로 입출력 버퍼는 기본으로 잡고 시작해야하는 문제인 셈이다.

* 오름차, 내림차순으로 정렬되는 우선순위큐 각각 1개씩 만들기

* left right로 나눠서 left는 내림차순 정렬 right는 오름차순 정렬을 한다.

* top은 항상 앞쪽이기때문에 이러한 형태로 만들어준다.

  * (left)rear---top (right)top---rear 형태로 보면 이해하기 편할거다.

<hr>

## 구현 형태
일단 항상 left에 넣는걸 기본 전제로 한다.

1. left가 비어있으면 left에 넣어준다.
2. 이후, left가 right보다 많이 들어있으면 right에 넣어준다.
    1.  그게 아닐때는, left에 넣어준다. 
3. left의 top과 right의 top을 비교했을때 left의 top이 더 크다면, 올바른 형태가 아니므로, left의 top과 right의 top을 swap처리해준다.
4. 이 작업이 모두 끝나면 ans에 left의 top를 넣어준다.

* 위의 형태로 구현이 끝난 ans를 출력해주면, 정답 처리가 된다.

> 접근 형태를 선형 배열구조를 반으로 잘라서, 작은거 오른쪽, 큰거 왼쪽으로 하면서 left의 top을 지속적으로 ans에 push해준다.

> left의 top은 항상 right의 top보다 작으므로, left에 2개 right에 2개의 값이 들어가서 더 작은 값으로 중간을 정해야하는 경우라도 예외없이, left의 top은 항상 right의 top보다 작게 구현했으므로, left의 top을 ans에 넣어주면된다. 

<hr>

## 소감

전체적으로 어렵게 느낄 수 있는 문제이다. 왜냐면 시간제한이 0.1초이기 때문에, 최대한 입력 받는 즉시 판별해서 출력을 해야한다. deque의 경우에는 양방향이 다 통하지만, 값이 정렬되지않아 크기에 대한 중간값 산출이 어렵고, vector와 stack또한 같은 이유에서 구현이 어렵다 그렇기에 우선순위큐를 사용해서 큐에 입력된 즉시 정렬되는 형태로 접근한다면, 나름 골드에서의 자료구조 치고는 쉽게 풀 수가 있다. 이러한 풀이를 까먹는다면, 다시 푸는데 힘겨울 수 있으므로, 꼼꼼하게 확인하는걸 추천한다.
